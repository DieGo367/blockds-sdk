// SPDX-License-Identifier: CC0-1.0
//
// SPDX-FileContributor: Michele Di Giorgio, 2024
//
// Gesture recognition example that use the $N Multistroke Recognizer from:
//
//     Anthony, L. and Wobbrock, J.O. (2010). A lightweight multistroke
//     recognizer for user interface prototypes. Proceedings of Graphics
//     Interface (GI '10). Ottawa, Ontario (May 31-June 2, 2010). Toronto,
//     Ontario: Canadian Information Processing Society, pp. 245-252.
//     https://dl.acm.org/citation.cfm?id=1839258
//
//     Anthony, L. and Wobbrock, J.O. (2012). $N-Protractor: A fast and
//     accurate multistroke recognizer. Proceedings of Graphics Interface
//     (GI '12). Toronto, Ontario (May 28-30, 2012). Toronto, Ontario:
//     Canadian Information Processing Society, pp. 117-120.
//     https://dl.acm.org/citation.cfm?id=2305296

#include <gl2d.h>
#include <nds.h>

#include "ndollar.h"

// This is autogenerated from gestures.png and gestures.grit
#include "gestures.h"

#define SCREEN_WIDTH     256
#define SCREEN_HEIGHT    192
#define TOUCH_BOX_RADIUS 3

Point stroke[SCREEN_WIDTH*SCREEN_HEIGHT];
u16   screen[SCREEN_HEIGHT][SCREEN_WIDTH];

// Low priority channel for background image
static int DMA_CHANNEL = 3;

void initBackground()
{
    //  Set up affine background 2 on main as a 8-bit color background.
    REG_BG2CNT = BG_BMP8_128x128 |
                 BG_BMP_BASE(8) | // The starting place in memory
                 BG_PRIORITY(2);  // A higher priority

    /*  Set the affine transformation matrix for the main screen background 3
     *  to be the identity matrix.
     */
    REG_BG2PA = 1 << 8;
    REG_BG2PB = 0;
    REG_BG2PC = 0;
    REG_BG2PD = 1 << 8;

    //  Place main screen background 2 at the bottom.
    REG_BG2X = 0;
    REG_BG2Y = 100;
}

void printGestures()
{
    glBegin2D();
    // Draw a square on the bottom screen to highlight the stroke.
    glPolyFmt(POLY_ALPHA(31) | POLY_CULL_NONE | POLY_ID(0));

    for (u16 i = 0; i < SCREEN_HEIGHT; ++i) {
        for (u16 j = 0; j < SCREEN_WIDTH; ++j)
            if (screen[i][j]) {
                glBoxFilled(
                    i - TOUCH_BOX_RADIUS,
                    j - TOUCH_BOX_RADIUS,
                    i + TOUCH_BOX_RADIUS,
                    j + TOUCH_BOX_RADIUS,
                    RGB8(146, 77, 200) | 0x8000
                );
            }
    }
    glEnd2D();
}

void clearGestures()
{
    for (u16 i = 0; i < SCREEN_HEIGHT; ++i) {
        for (u16 j = 0; j < SCREEN_WIDTH; ++j) {
            screen[i][j] = 0;
        }
    }
}

int main(int argc, char **argv)
{
    // Initialize display:
    // - sub screen (top): console output
    // - main screen (bottom): GL2D graphics
    consoleDemoInit();
    lcdSwap();

    vramSetPrimaryBanks(VRAM_A_MAIN_BG_0x06000000, VRAM_B_MAIN_BG_0x06020000,
                        VRAM_C_SUB_BG_0x06200000, VRAM_D_LCD);
    videoSetMode(MODE_0_3D |
                 DISPLAY_BG2_ACTIVE);
    glScreen2D();

    printf("Gesture recognition example\n");
    printf("===========================\n");
    printf("\n");
    printf("A: Recognize the current gesture\n");
    printf("START: Return to loader\n");
    printf("Use touch screen to draw. Number of strokes has to be the same:\n");

    // Display template gestures as a background image
    dmaCopyHalfWords(DMA_CHANNEL,
                     gesturesBitmap,
                     (uint16 *)BG_BMP_RAM(0),
                     gesturesBitmapLen);

    initBackground();

    touchPosition   touch_pos    = { 0, 0, 0, 0, 0, 0 };
    unsigned int    strokeLength = 0;
    NDRecognizer_s *ndrec        = createNDRecognizer();

    u16 clear = 1;
    clearGestures();

    while (1)
    {
        swiWaitForVBlank();

        scanKeys();
        uint16_t keys_held = keysHeld();
        uint16_t keys_down = keysDown();

        // Handle key presses.
        if (keys_down & KEY_START) {
            break;
        }

        // If pen down, update touch input.
        if (keys_held & KEY_TOUCH)
        {
            if (clear) {
                clearGestures();
                clear = 0;
            }

            touchRead(&touch_pos);
            stroke[strokeLength].x = (double) touch_pos.px;
            stroke[strokeLength].y = (double) touch_pos.py;
            strokeLength++;

            screen[touch_pos.px][touch_pos.py] = 1;
        } else {
            if (strokeLength > 0) {
                addGesture(ndrec, stroke, strokeLength);
                strokeLength = 0;
            }
        }

        if (keys_down & KEY_A) {
            Result res = recognize(ndrec);
            printf("Result: %s (score: %.2f)\n", res.name, res.score);
            flushGestures(ndrec);
            clear = 1;
        }

        printGestures();
        glFlush(0);
    }

    destroyNDRecognizer(ndrec);

    return 0;
}

